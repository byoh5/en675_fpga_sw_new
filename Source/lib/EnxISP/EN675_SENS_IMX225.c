/* **************************************************************************
 File Name	:	EN675_SENS_IMX225.c
 Description:	EN675 - IMX225 device driver
 Designer	:	Sung, Min-Je
 Date		:	19. 6. 11
 Copyright ⓒ Eyenix Co., Ltd. All Rights Reserved.
*************************************************************************** */

#define __SENS_LIST__
#include "dev_model.h"				// EN675 - __SENS_LIST__
#define model_Sens	SENS_IMX225

#include "isp_lib_main.h"

//-------------------------------------------------------------------------------------------------

	const WORD gwTblIMX225[][2] = {
							{0x3005, 0x00},			// AD10bit
							{0x3006, 0x00},
							{0x3009, 0x01},
							{0x3018, 0x28},
							{0x3019, 0x05},
							{0x301B, 0xCA},
							{0x301C, 0x08},
							{0x3044, 0x01},			//	MIPI Setting
							{0x3054, 0x66},
							{0x305C, 0x2C},			//	INCLK Setting 27MHz
							{0x305D, 0x00},
							{0x305E, 0x2C},
							{0x305F, 0x00},

							{0x3344, 0x10},
							{0x3346, 0x03},
							{0x3353, 0x0E},
							{0x3357, 0xD1},
							{0x3358, 0x03},
							{0x336B, 0x37},
							{0x336C, 0x1F},
							{0x3382, 0x5F},
							{0x3383, 0x17},
							{0x3384, 0x37},
							{0x3385, 0x17},
							{0x3386, 0x17},
							{0x3387, 0x17},
							{0x3388, 0x4F},
                            {0x3389, 0x27},
                            {0x337D, 0x0A},			//	RAW10
                            {0x337E, 0x0A},
                            {0x3380, 0x00},			//	INCLK Setting 27MHz
                            {0x3381, 0x1B},
                            {0x338D, 0x3D},
                            {0x338E, 0x01},

							{0x300F, 0x00},
							{0x3012, 0x2C},
							{0x3013, 0x01},
							{0x3016, 0x09},
							{0x301D, 0xC2},
							{0x3070, 0x02},
							{0x3071, 0x01},
							{0x309E, 0x22},
							{0x30A5, 0xFB},
							{0x30A6, 0x02},
							{0x30B3, 0xFF},
							{0x30B4, 0x01},
							{0x30B5, 0x42},
							{0x30B8, 0x10},
							{0x30C2, 0x01},

							{0x310F, 0x0F},
							{0x3110, 0x0E},
							{0x3111, 0xE7},
							{0x3112, 0x9C},
							{0x3113, 0x83},
							{0x3114, 0x10},
							{0x3115, 0x42},
							{0x3128, 0x1E},
							{0x31ED, 0x38},

							{0x320C, 0xCF},
							{0x324C, 0x40},
							{0x324D, 0x03},
							{0x3261, 0xE0},
							{0x3262, 0x02},
							{0x326E, 0x2F},
							{0x326F, 0x30},
							{0x3270, 0x03},
							{0x3298, 0x00},
							{0x329A, 0x12},
							{0x329B, 0xF1},
							{0x329C, 0x0C}
							};


	const BYTE gbTblIMX225_0[][2] = {		// 27MHz - 720/60P
								{0x00, 0x01}, 	// STANDBY
								{0x02, 0x00},	// Sensor Master Mode
								//{0x05, 0x01},	// AD12bit		TODO KSH IMX225의 AD bit 설정은?, EN673에서는 12bit으로 설정됨
								//{0x05, 0x00},	// 10bit Set AD	//150421 HSH --> 151005 HSH ???o??
								{0x07, 0x10},
								{0x09, 0x00},
								{0x0a, 0x00}, 	// BLKLEVEL_LSB[7:0]
								{0x0b, 0x00}, 	// BLKLEVEL_MSB[0]
								{0x0F, 0x00},
								{0x12, 0x2C},
								{0x13, 0x01},
								{0x16, 0x09},
								{0x18, 0xEE},
								{0x19, 0x02},
								{0x1B, 0xE4},
								{0x1C, 0x0C},
								{0x1D, 0xC2},
								{0x44, 0x00},	//10bit Set		//150421 HSH
								{0x46, 0x01},	//DCK Synchronous Register1
								{0x47, 0x03},	//DCK Synchronous Register2
								{0x48, 0xC0},	//DCK Synchronous Register3
								{0x49, 0x0A},
								{0x49, 0x0A},
								{0x70, 0x02},
								{0x71, 0x01},
								{0x9E, 0x22},
								{0xA5, 0xFB},
								{0xA6, 0x02},
								{0xB3, 0xFF},
								{0xB4, 0x01},
								{0xB5, 0x42},
								{0xB8, 0x10},
								{0xC2, 0x01}
								};

	const BYTE gbTblIMX225_1[][2] = { 						// ID 0x03
								{0x0F, 0x0F},
								{0x10, 0x0E},
								{0x11, 0xE7},
								{0x12, 0x9C},
								{0x13, 0x83},
								{0x14, 0x10},
								{0x15, 0x42},
								{0x28, 0x1E},
								{0xED, 0x38}
								};

	const BYTE gbTblIMX225_2[][2] = {						// ID 0x04
								{0x0C, 0xCF},
								{0x4C, 0x40},
								{0x4D, 0x03},
								{0x61, 0xE0},
								{0x62, 0x02},
								{0x6E, 0x2F},
								{0x6F, 0x30},
								{0x70, 0x03},
								{0x98, 0x00},
								{0x9A, 0x12},
								{0x9B, 0xF1},
								{0x9C, 0x0C}
								};

void InitSensRun(void)
{
	if(gbSensIntf==0) {	// Parallel
		UINT i;
		for(i=0;i<ARRAY_SIZE(gbTblIMX225_0);i++)	{	SetSens(0x3000|gbTblIMX225_0[i][0], gbTblIMX225_0[i][1]);	}		//	ID2		// TODO KSH IMX225 초기설정 배열크기가 맞지 않음
		for(i=0;i<ARRAY_SIZE(gbTblIMX225_1);i++)	{	SetSens(0x3100|gbTblIMX225_1[i][0], gbTblIMX225_1[i][1]);	}		//	ID3
		for(i=0;i<ARRAY_SIZE(gbTblIMX225_2);i++)	{	SetSens(0x3200|gbTblIMX225_2[i][0], gbTblIMX225_2[i][1]);	}		//	ID4

		WaitXus(1000);	SetSens(0x3000, 0x01);
		WaitXus(1000);	SetSens(0x3000, 0x00);
		WaitXus(1000);	SetSens(0x3000, 0x00);
		WaitXus(3000);	SetSens(0x3002, 0x00);
		WaitXus(3000);	SetSens(0x3049, 0x0A); 	// Wait for internal regulator stabilization

		// SensClk
		SetSens(0x305D, 0x00);	//INCKSEL2
		SetSens(0x305F, 0x00);	//INCKSEL4
	}
	else if(gbSensIntf==2) {	// MIPI
		//SetSens(0x3000, 0x1);	WaitXus(200000);		// standby
		//SetSens(0x3002, 0x1);	WaitXus(200000);		// xmaster stop
		//SetSens(0x3001, 0x01);						// REG Hold
		//SetSens(0x3003, 0x01);						// SW rese
		WaitXus(1000);	SetSens(0x3000, 0x01);
		WaitXus(1000);	SetSens(0x3001, 0x01);
		WaitXus(1000);	SetSens(0x3002, 0x00);	WaitXus(1000);

		for(UINT i=0;i<ARRAY_SIZE(gwTblIMX225); i++)
		{
			SetSens(gwTblIMX225[i][0],gwTblIMX225[i][1]);
			WaitXus(100);
		}

		//SetSens(0x3000, 0x0);	WaitXus(600000);		// standby cancel
		//SetSens(0x3002, 0x0);	WaitXus(400000);		// xmaster
		WaitXus(1000);	SetSens(0x3000, 0x00);
		WaitXus(1000);	SetSens(0x3001, 0x00);
		WaitXus(1000);	SetSens(0x3002, 0x00);
		WaitXus(3000);	SetSens(0x3049, 0x0A); 	// Wait for internal regulator stabilization
	}
}

